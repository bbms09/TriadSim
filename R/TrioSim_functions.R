setwd("C:/Users/shi2/Desktop/Cleft/FOr Min/TrioSim")

#' Pick target SNPs in the pathway
#' 
#' 
#' The target SNPs in the pathway can be picked by users manually or use this facility function.
#' It helps pick the set of target SNPs in the pathway(s) based on a 
#' desired allele frequency.
#' @param input.plink.file is a vector of two character strings for the file names of the mother's
#' and  father's plink base filenames. The plink files are in bed format and three files with 
#' extensions .bed .bim and .fam are expected for each parent's genotypes. In addition the allele 
#' frequnecy files generated by PLINK (base filename with .frq extension) are expected to be in the
#' working directory.
#' @param fr.desire is a double number giving the desired frequency of the target SNPs. 
#' @param n.snp is an integer giving the number of target SNPs to be picked.
#'
#' @return The function returns a list of two: first element is  the SNPs read from the .bim file now with 
#' allele frequncies merged and the second is the row numbers of the target SNPs selected
#' among all SNPs in the .bim file.
#' @export
#'
#' @examples pick_target.snp(c('cau_mom','cau_dad'),0.05, 8)
pick_target.snp <- function(input.plink.file, fr.desire="double", n.snp="integer") {
  #if (!file.exists(paste(input.plink.file[1],'frq',sep='.'))) system(paste('plink.exe --noweb  --bfile ',input.plink.file[1],'--freq --out',input.plink.file[1]))
  #if (!file.exists(paste(input.plink.file[2],'frq',sep='.'))) system(paste('plink.exe --noweb  --bfile ',input.plink.file[2],'--freq --out',input.plink.file[2]))
  
  if (!file.exists(paste(input.plink.file[1],'frq',sep='.'))) stop(paste(input.plink.file[1],'.frq',
                                                                         "is needed for selecting target SNPs",sep=' '))
  if (!file.exists(paste(input.plink.file[2],'frq',sep='.'))) stop(paste(input.plink.file[2],'.frq',
                                                                         "is needed for selecting target SNPs",sep=' '))
  
  read.table(paste(input.plink.file[1],'frq',sep='.'),header=T,as.is=T)->fr.mom
  read.table(paste(input.plink.file[2],'frq',sep='.'),header=T,as.is=T)->fr.dad
  fr<- fr.mom
  fr$MAF <- (fr.mom$MAF+fr.dad$MAF)/2
  
  read.table(paste(input.plink.file[1],'bim',sep='.'),as.is=T)->snp
  snp$ord <- 1:nrow(snp)
  snp.all2 <- merge(snp,fr,by.x='V2',by.y='SNP')
  snp.all2<- snp.all2[order(snp.all2$ord),]
  .mar <- 0.005
  snp.in.fr <- which(abs(snp.all2$MAF-fr.desire)<.mar)
  
  while(length(snp.in.fr)< n.snp+2) {.mar <- .mar+0.001; snp.in.fr <- which(abs(snp.all2$MAF-fr.desire)<.mar)}
  target.snp <- snp.in.fr[seq(1,length(snp.in.fr),length(snp.in.fr)/(n.snp+2))][2:(n.snp+1)]
  return(list(snp.all2, target.snp))
}

#' Getting genotypes of the target SNPs 
#' 
#' 
#' This function read out the genotypes of the target SNPs from the orignal data set (the data set on
#' which simulation is based). 
#'
#' @param input.plink.file is a vector of three character strings for the file names of the mother's
#' father's and child's plink base filenames. The plink files are in bed format and three files with 
#' extensions .bed .bim and .fam are expected for each individual's genotypes. The mothers, fathers, and 
#' childredn must be from the same set of trio families even though the ordering of the families can be different
#' for the three sets of data.
#' @param target.snp is a vector of integers showing the row number of the target SNPs in the .bim file
#' @param snp.all2 is a dataframe containing list of SNPs in PLINK .bim format. Only the second column is used which contains
#' the rs number of the SNPs. The colname name of the second column has to be "V2".
#'
#' @return A list of three matrices is returned. The three matrices are the observed genotypes of the mothers, fathers
#' and children/complements at the target SNPs.
#' @export
#'
#' @examples tar.snp <- c(10, 203, 342, 500)
#' assuming snps contains the data frame read from the .bim file.
#' get.target.geno(c('cau_mom','cau_dad','cau_kid'), tar.snp,snps)
get.target.geno <- function(input.plink.file, target.snp,snp.all2) {
  geno.mom <- snpStats::read.plink(paste(input.plink.file[1],'bed',sep='.'),select.snps= snp.all2[target.snp,'V2'], na.strings = ("-9"))
  geno.dad <- snpStats::read.plink(paste(input.plink.file[2],'bed',sep='.'),select.snps= snp.all2[target.snp,'V2'], na.strings = ("-9"))
  geno.kid <- snpStats::read.plink(paste(input.plink.file[3],'bed',sep='.'),select.snps= snp.all2[target.snp,'V2'], na.strings = ("-9"))
  
  mom <- geno.mom$genotype@.Data
  mom <- mom[order(rownames(mom)),]
  dad <- geno.dad$genotype@.Data
  dad <- dad[order(rownames(dad)),]
  kid <- geno.kid$genotype@.Data
  kid <- kid[order(rownames(kid)),]
  
  mom <- matrix(as.numeric(mom),byrow=F,ncol=ncol(mom))
  dad <- matrix(as.numeric(dad),byrow=F,ncol=ncol(dad))
  kid <- matrix(as.numeric(kid),byrow=F,ncol=ncol(kid))
  mom[mom==0] <- NA; mom <- mom-1
  dad[dad==0] <- NA; dad <- dad-1
  kid[kid==0] <- NA; kid <- kid-1
  
  na.sel <- sum(is.na(mom)|is.na(dad)|is.na(kid))
  mom[na.sel] <-0
  dad[na.sel] <-0
  kid[na.sel] <-0
  comp <- mom+dad-kid
  
  mom[!(comp%in%c(0,1,2))] <- 0
  dad[!(comp%in%c(0,1,2))] <- 0
  kid[!(comp%in%c(0,1,2))] <- 0
  comp[!(comp%in%c(0,1,2))] <- 0
  mom <- 2-mom
  dad <- 2-dad
  kid <- 2-kid
  comp <- 2-comp
  ### stack case trio on top of comp trio
  mom <- rbind(mom,mom)
  dad <- rbind(dad,dad)
  kid <- rbind(kid, comp)
  n.gwas <- nrow(kid)
  
  mom.tar <- mom
  dad.tar <- dad
  kid.tar <- kid
  return(list(mom.tar,dad.tar, kid.tar))
}

#' Picking chromosomal breaking points
#' 
#' 
#' The breaking points at each chromosome can be picked manually or use this function. 
#' When a dataframe containing the recombination rate (rcmb.rate) is provided the function
#' tends to pick the breaking points at recombination hotspots.
#'
#' @param N.brk is an integer giving the number of breaks to be picked for each chromosome.
#' @param n.ped is an integer giving the number of trios to be simulated
#' @param snp.all2 is a dataframe containing the list of SNPs in PLINK .bim format. Two columns of the dataframe
#' is used: column 1 with column name "V1" containing the chromosome number and column 4 with column name "V4"
#' containing the chromosomal postion of the SNPs.
#' @param target.snp is a vector of integers showing the row number of the target SNPs in the .bim file.
#' @param rcmb.rate the default value is NA. rcmb.rate is a dataframe containing the recombination rates at each SNP. The ordering of the SNPs should 
#' be identical to that of snp.all2. It contains 4 columns with column names "V1", "V2","V3",and "V4" with the 
#' corresponding values for "the chromosomal number", "SNP rs number", "chromosomal position",
#' and "recombination rate". The recombination rate represents the maximum recombination rate in the chromosomal
#' region between the current SNP and the SNP above (or the first basepair of the chromosome for the first SNP on a chromosome).
#' When no rcmb.rate is provided the function will pick the breaking points randomly where keeping the breaking
#' points in between target SNPs.
#'
#' @return A list of two elements is returned. The first one is a matrix of integers showing where 
#' the chromosomal breaks is to take place for each individual in the simulated trios. The second one
#' is a matrix showing the chromosomal segments out of which is each target SNP selected for each simulated trio.
#' @export
#'
#' @examples 
#' found.brks <- get.brks(N.brk=3,n.ped=1000, snp.all2, target.snp,rcmb.rate=NA)
#' breaks <- found.brks[[1]]
#' family.pos <- found.brks[[2]] 
#' 
#' 
get.brks <- function(N.brk,n.ped, snp.all2, target.snp,rcmb.rate=NA,same.brk=FALSE){
  ### target SNPs must be sorted from smallest to largest
  if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  ## two breaking points on each chr so 3 segments
  n.ped <- n.ped * 1.2
  n.chr <- length(table(snp.all2$V1)) 
  snp.per.chr <- rep(NA,n.chr)
  for (i in 1:n.chr) {
    if (i==1) snp.per.chr [i] <- length(which(target.snp<cumsum(table(snp.all2$V1))[1])) else 
      snp.per.chr [i] <- length(which(target.snp<cumsum(table(snp.all2$V1))[i] & target.snp>cumsum(table(snp.all2$V1))[i-1]))
  }
  #sort(c(0,cumsum(table(snp.all2$V1)), target.snp))[(c(0,cumsum(snp.per.chr))[i]):(c(0,cumsum(snp.per.chr))[i+1]+1)+1]
  brks <- NULL
  brk.ends <- NULL
  for (i in 1:n.chr) {
    ## if >=2 target SNPs on the chromosome if more target SNPs on chr the number of breaks will be >N.brk for that chr
    ## put breaks in between target.SNPs else put break ends evenly
    if (snp.per.chr[i]>1) {
      if (i==1) {brk0 <- c(1,target.snp[1]-1 )} else {first.pos <- cumsum(table(snp.all2$V1))[i-1]+1
      last.pos <- target.snp[which(target.snp> cumsum(table(snp.all2$V1))[i-1])[1]]-1
      brk0 <- c(first.pos,last.pos )} ## fragment before the first SNP
      brk1 <- c(target.snp[cumsum(snp.per.chr)[i]]+1,cumsum(table(snp.all2$V1))[i] ) ## fragment after the last SNP
      if ((snp.per.chr[i]) < N.brk) brk.ends <- rbind(brk.ends,brk0)
      for (k in 2:snp.per.chr[i]) {
        brk.ends<- rbind(brk.ends,c(target.snp[c(0,cumsum(snp.per.chr))[i]+k-1],target.snp[c(0,cumsum(snp.per.chr))[i]+k]))
      } 
      if ((snp.per.chr[i]-1) < N.brk) brk.ends <- rbind(brk.ends,brk1)
    } else {brk <-  c(1,ceiling(quantile(1:table(snp.all2$V1)[i],(1:(N.brk))/(N.brk))))
    if (i>1) addon <- cumsum(table(snp.all2$V1))[i-1] else addon <-0
    for (k in 2:length(brk))  brk.ends <- rbind(brk.ends, c(brk[k-1],brk[k]-1) + addon)
    }
  }
  
  if (length(rcmb.rate)>1 & sum(snp.all2$V4==rcmb.rate$V4)==nrow(snp.all2)) {
    brks <- NULL
    for (i in 1:nrow(brk.ends)) {
      rate1 <- rcmb.rate[brk.ends[i,1]:(brk.ends[i,2]-1),4]
      brks <- cbind(brks, sample(brk.ends[i,1]:(brk.ends[i,2]-1), size=n.ped*1.2,prob= rate1,replace=T))
      brks <- cbind(rep(0,n.ped),brks,matrix(rep(cumsum(table(snp.all2$V1)),n.ped),byrow=T,nrow=n.ped))   }
  } else  {
    brks <- apply(brk.ends,1,function(v){return(sample((v[1]-1):v[2],n.ped,replace=T))})
    brks <- cbind(rep(0,n.ped),brks,matrix(rep(cumsum(table(snp.all2$V1)),n.ped),byrow=T,nrow=n.ped)) }  
  
  ## request more brks than needed so that the ones with identical breaking points for different segment can be removed
  brks <- t(apply(brks,1,sort))
  n.ped <- n.ped/1.2
  brks <- brks[apply(brks,1,function(v){sum(duplicated(v))})==0,][1:n.ped,]
  ## find position in terms of the chromosome segments (which segment) in sel.fam the fam to be used for each target pos
  fam.pos <- NULL
  for (k in 1:length(target.snp)) {
    fam.pos <- cbind(fam.pos,apply(brks < target.snp[k],1,sum))
  }
  if (same.brk) {
    brks <- matrix(rep(brks[1,],nrow(brks)),byrow=T,nrow=nrow(brks))
    fam.pos <- matrix(rep(fam.pos[1,],nrow(fam.pos)),byrow=T,nrow=nrow(fam.pos))
  }
  return(list(brks,fam.pos))
}

#' Selecting families based on the risk model
#' 
#' This function selects families based on the prespecified risk model. It can simulate a homogenous scenario
#' or a stratified scenarios with two subpopulations. For a stratified scenarion the input mom.tar, dad.tar, and
#' kid.tar become a list of two matrices, see Arguments for detail. When e.fr is givin rather than the default NA
#' the risk model can involve exposure main effects as well as gene by exposure interation. This function is parallelized
#' and the number of cores for parallelization is set of the total number of CPU cores minus one.
#'
#' @param n.ped is an integer giving the number of trios to be simulated
#' @param brks a matrix of integers showing where the chromosomal breaks is to take place for 
#' each individual in the simulated trios.
#' @param target.snp is a vector of integers showing the row number of the target SNPs in the .bim file.
#' @param fam.pos is a matrix showing the chromosomal segments out of which is each target SNP 
#' selected for each simulated trio.
#' @param mom.tar is a matrix containing the target SNP genotypes of the mothers in the original data 
#' for simulations of a homogenous population. For simulations under population stratification it is 
#' a list of two matrices each containing mothers' target SNP genotypes in one of the two subpopulations.
#' @param dad.tar is a matrix containing the target SNP genotypes of the fathers in the original data
#' for simulations of a homogenous population. For simulations under population stratification it is 
#' a list of two matrices each containing fathers' target SNP genotypes in one of the two subpopulations.
#' @param kid.tar is a matrix with the target SNP genotypes of the children stacking on top of the complements in the original data
#' for simulations of a homogenous population. For simulations under population stratification it is 
#' a list of two matrices each containing children's target SNP genotypes in one of the two subpopulations.
#' @param pathways is a list of vectors of integers. Each vector of integers denotes the SNPs involved in a particular pathway. E.g. list(1:4,5:8)
#' @param betas.e0 is a vector of doubles giving the beta coefficient of the logit risk model for the unexposed individuals.
#' @param e.fr is a double number between 0 and 1 which gives the exposure prevalence.
#' @param betas.e is a vector of doubles giving the beta coefficient of the logit risk model for the exposed individuals.
#' @param pop1.frac is a double number between 0 and 1 which gives the fraction of population 1 for a population stratification scenario.
#' @param rate.beta is a double number giving the log OR of disease prevalence in population 2 over that in population 1.
#' @param qtl is a boolean variable denoting whether a quantitative trait (qtl=TRUE) or a binary trait (qtl=FALSE) is to be simulated. For a binary trait only affected 
#' families will be kept. The default value is qtl=FALSE.
#' @param out.put.file is a character string giving the base file name for the output file. When a non-default value is given the fucntion will write the following files to 
#' the current working directory: 
#' a file with name ending with "exp.txt" containing the exposure data when exposure is involved in the risk model.
#' a file with name ending with "pop.txt" containing information on subpopulation membership when the simulation involves a stratified scenario.
#' a file with name ending with "pheno.tx" containing quantitative trait phenotype when a quantitative trait is involved.
#' When out.put.file is the default value NA the file names for the above three files are: exposure.txt, population.txt, phenotype.txt.
#' @param no_cores is an integer which specifies the number of CPU cores to parallelized.
#' @return The function returns a list of five elements. The first one is a matrix of integer giving the families (in terms of row number) 
#' selected for each chromosomal segment and each simulated trio. The second one is a matrix giving the genotypes on the 
#' target SNPs in the simulated trio. The third one is a vector of 0's and 1's giving the exposure status of each simulated trio when the risk model involves
#' exposure. The fourth element is a vector of 1's and 2's giving the subpopulation group of each simulated trio. The fifth element is a vector of doubles giving the phenotype 
#' values for simulations of a quantitative trait.
#' @export
#' @importFrom foreach %dopar%
#'
#' @examples 
#' tar.snp <- c(10, 203, 342, 500)
#' found.brks <- get.brks(N.brk=3,n.ped=1000, snp.all2, target.snp,rcmb.rate=NA)
#' breaks <- found.brks[[1]]
#' family.pos <- found.brks[[2]] 
#' betas <- c(-6.4, 3.2, 5.8)
#' pwy <- list(1:4,5:8)
#' fit.risk.model.par(n.ped=1000,brks=breaks,target.snp=tar.snp,fam.pos=family.position, 
#' mom.tar=mom.target,dad.tar=dad.target, kid.tar=kid.target, pathways=pwy, 
#' betas, e.fr=NA, betas,pop1.frac=0.5,rate.beta=0.3)

fit.risk.model.par <- function(n.ped,brks,target.snp,fam.pos, mom.tar,dad.tar, kid.tar, pathways, betas.e0, e.fr=NA, betas.e,pop1.frac=NA,rate.beta= NA,qtl=FALSE,out.put.file=NA,no_cores=NA) {
  two.pop <- length(mom.tar)==2
  brks.org <- brks
  fam.pos.org <- fam.pos
  mom.tar.org <- mom.tar
  dad.tar.org <- dad.tar
  kid.tar.org <- kid.tar
  betas.e0.org <- betas.e0
  betas.e.org <- betas.e
  e.fr.org <- e.fr
  if (length(betas.e0) != 1+length(pathways) ) stop("Number of beta coefficients does not match number of pathways")
  if (length(betas.e) != 1+length(pathways) ) stop("Number of beta coefficients does not match number of pathways")
  
  sim.fam <- function(i) {
    aff <- 0
    while (aff==0) {
      ### decide which population first ###
      pop <- NA
      if (two.pop)   {pop <- sample(c(1,2),1,prob=c(pop1.frac,1-pop1.frac))
      #brks <- brks.org[[pop]]
      #fam.pos <- fam.pos.org[[pop]]
      mom.tar <- mom.tar.org[[pop]]
      dad.tar <- dad.tar.org[[pop]]
      kid.tar <- kid.tar.org[[pop]]
      betas.e0 <- betas.e0.org; betas.e0[1] <- betas.e0[1] + (pop==2)*rate.beta
      betas.e <- betas.e.org; betas.e[1] <- betas.e[1] + (pop==2)*rate.beta
      e.fr <- e.fr.org[pop]
      }
      n.gwas <- nrow(mom.tar)
      n.seg <- ncol(brks)-1
      n.ped <- nrow(fam.pos)
      e <- 0 ## use betas.e0 when e=0 or  when no exposure in the risk model
      if (!is.na(e.fr)) {
        e <- sample(c(0,1),1,prob=c(1-e.fr,e.fr))
      }
      if (e==0) betas <- betas.e0 else  betas <- betas.e  
      
      brk <- brks[i,]
      sel.fam <- sample(1:n.gwas,n.seg,replace=T)
      ### for each target SNP which fragment was used -> get the corresponding sel.fam for target.snp 1 to n.snp
      pathway.m <- mom.tar[cbind(sel.fam[fam.pos[i,]],1:length(target.snp))]
      pathway.f <- dad.tar[cbind(sel.fam[fam.pos[i,]],1:length(target.snp))]
      pathway.c <- kid.tar[cbind(sel.fam[fam.pos[i,]],1:length(target.snp))]
      
      X<- NULL
      for (p in 1:length(pathways)) {pathway1 <- pathways[[p]];
      X<- c(X,1*(sum(pathway.c[pathway1]>0)==length(pathway1)))}
      linear.pred <- betas[1] + sum(X*betas[-1])
      if (qtl) linear.pred <- linear.pred + rnorm(1)
      p_case =  exp(linear.pred)/(1+exp(linear.pred))
      aff <-rbinom(1,1, p_case)
      if (qtl) aff <- 1
    }
    c(i,e,pop, sel.fam, pathway.m,pathway.f,pathway.c,linear.pred)
  }
  if (is.na(no_cores)) no_cores <- ceiling(parallel::detectCores()/2)
  cl<-parallel::makeCluster(no_cores)
  doParallel::registerDoParallel(cl)
  sim.all <- foreach::foreach(i = 1:n.ped, 
                              .combine = rbind, 
                              .export = c('n.ped','mom.tar','dad.tar', 'kid.tar', 'betas.e0', 'e.fr', 'betas.e')) %dopar%  
    sim.fam(i)
  # Finish
  parallel::stopCluster(cl)
  foreach::registerDoSEQ()
  pathway.all <- sim.all[,-(1:(ncol(brks)+2))]
  pheno <- pathway.all[,ncol(pathway.all)]
  pathway.all <- pathway.all[,-ncol(pathway.all)]
  n.snp <- ncol(pathway.all)/3
  pathway.all <- rbind(pathway.all[,1:n.snp],pathway.all[,1:n.snp+n.snp],pathway.all[,1:n.snp+2*n.snp])
  sel.fam.all  <- sim.all[,1:(ncol(brks)-1)+3]
  e.vec <- sim.all[,2]
  pop.vec <- sim.all[,3]
  if (!is.na(e.fr)) if (is.na(out.put.file)) write(e.vec,ncol=1,file='exposure.txt') else write(e.vec,ncol=1,file=paste(out.put.file,'exp.txt'))
  if (two.pop)  if (is.na(out.put.file)) write(pop.vec,ncol=1,file='population.txt') else write(pop.vec,ncol=1,file=paste(out.put.file,'pop.txt'))
  if (qtl)  if (is.na(out.put.file)) write(pheno,ncol=1,file='phenotype.txt') else write(pop.vec,ncol=1,file=paste(out.put.file,'pheno.txt'))
  
  return(list(sel.fam.all, pathway.all,e.vec,pop.vec,pheno))
}

#' Splicing chromosomal segments
#' 
#' 
#' This function splice the chromosomal segments into "complete" trios. The spliced trio sets are written into separate plink
#' file chromosome by chromosome. It is parallelized and if no no_cores value is given the total number
#' of CPUs available will be used in the parallelization.
#'
#' @param input.plink.file for simulations of homogenous population, it is a vector of three character strings for the base filenames of the mother's
#' father's and child's plink base filenames. The plink files are in bed format and three files with 
#' extensions .bed .bim and .fam are expected for each individual's genotypes. The mothers, fathers, and 
#' childredn must be from the same set of trio families even though the ordering of the families can be different
#' for the three sets of data. For simulations under population stratification it is a list of two vectors. Each vector is a vector 
#' of three character strings for the base filenames as described above.The two vectors correspond to the two subpopulations.
#' @param out.put.file is a character string giving the base file name for the output file. The final file name also contains information on chromosome
#' number. E.g., for a base filename "trio" and for chromosome 1 the final file name is "trio1sim".
#' @param brks is a matrix of integers showing where the chromosomal breaks is to take place for each individual in the simulated trios.
#' @param sel.fam.all is a matrix of integer giving the families (in terms of row number) selected for each chromosomal segment and each simulated trio.
#' @param snp.all2 is a dataframe containing the list of SNPs in PLINK .bim format. Two columns of the dataframe
#' is used: column 1 with column name "V1" containing the chromosome number and column 2 with column name "V2" containing the rs number of the SNPs.
#' @param pathway.all is a matrix giving the genotypes on the target SNPs in the simulated trio.
#' @param target.snp is a vector of integers showing the row number of the target SNPs in the .bim file.
#' @param pop.vec is a vector of 1's and 2's giving the subpopulation group of each simulated trio.
#' @param no_cores is an integer which specifies the number of CPU cores to parallelized.
#'
#' @return This function does not return values. Instead it writes PLINK files into the current directory. Each set of PLINK files contains genotype
#' data for one chromosome for all trios. The first third of the rows are genotypes of the mothers'. The seond third are those of the fathers' and the last third are the 
#' children's. 
#' @export
#' @importFrom foreach %dopar%
#'
#' @examples glue.chr.segment.par(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec=NA,no_cores=NA) 
glue.chr.segment.par <- function(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec=NA,no_cores=NA) {
  if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  n.ped <- nrow(brks)
  sel.fam.all.org <- sel.fam.all
  chr.brk <- c(0,which(brks[1,]%in%cumsum(table(snp.all2$V1))))
  risk.chr <-  sapply(target.snp,function(v){sum(v>cumsum(table(snp.all2$V1)))+1})
  chr.pos <- target.snp - c(0,cumsum(table(snp.all2$V1)))[risk.chr]
  
  input.plink.file.org <- input.plink.file
  if (length(input.plink.file)==2) pop <- 2 else pop <- 1
  
  ### randomly switch mother/father to remove maternal effects in the original data #########
  mf.flip <- matrix(rbinom(n.ped*(ncol(brks)-1),1,0.5),ncol=ncol(brks)-1,nrow=n.ped)
  splice.chr <- function(one.chr) {
    mom.all <- NULL
    dad.all <- NULL
    kid.all <- NULL
    n.ped.pop1 <-0
    for (p in 1:pop) {
      chr <- unique(snp.all2$V1)[one.chr]
      if (pop==1) {
      geno.mom <- snpStats::read.plink(paste(input.plink.file[1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      geno.dad <- snpStats::read.plink(paste(input.plink.file[2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      geno.kid <- snpStats::read.plink(paste(input.plink.file[3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      } else {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[[p]][1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[[p]][2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[[p]][3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      }
      mom <- geno.mom$genotype@.Data
      mom <- mom[order(rownames(mom)),]
      dad <- geno.dad$genotype@.Data
      dad <- dad[order(rownames(dad)),]
      kid <- geno.kid$genotype@.Data
      kid <- kid[order(rownames(kid)),]
      geno.mom$genotype <-NULL
      
      rm(geno.dad,geno.kid)
      gc()
      mom <- matrix(as.numeric(mom),byrow=F,ncol=ncol(mom))
      dad <- matrix(as.numeric(dad),byrow=F,ncol=ncol(mom))
      kid <- matrix(as.numeric(kid),byrow=F,ncol=ncol(mom))
      mom[mom==0] <- NA; mom <- mom-1
      dad[dad==0] <- NA; dad <- dad-1
      kid[kid==0] <- NA; kid <- kid-1
      
      na.sel <- sum(is.na(mom)|is.na(dad)|is.na(kid))
      mom[na.sel] <-0
      dad[na.sel] <-0
      kid[na.sel] <-0
      comp <- mom+dad-kid
      
      mom[!(comp%in%c(0,1,2))] <- 0
      dad[!(comp%in%c(0,1,2))] <- 0
      kid[!(comp%in%c(0,1,2))] <- 0
      comp[!(comp%in%c(0,1,2))] <- 0
      mom <- 2-mom
      dad <- 2-dad
      kid <- 2-kid
      comp <- 2-comp
      ### stack case trio on top of comp trio
      mom.all <- rbind(mom.all,mom,mom)
      rm(mom);gc()
      dad.all <- rbind(dad.all,dad,dad)
      rm(dad);gc()
      kid.all <- rbind(kid.all, kid, comp)
      rm(kid,comp);gc()
      
      if (p==1 & pop==2) n.ped.pop1 <- nrow(mom.all)
    }
    mom <- mom.all; rm(mom.all);gc()
    dad <- dad.all; rm(dad.all);gc()
    kid <- kid.all; rm(kid.all);gc()
    #  brks <- brks.org
   if (pop==2) sel.fam.all[pop.vec==2,] <- sel.fam.all.org[pop.vec==2,] + n.ped.pop1
    
    moms<- NULL
    dads <- NULL
    kids <- NULL
    for (i in 1:n.ped) {
      mom1 <- NULL
      dad1 <- NULL
      kid1 <- NULL
      
      brks1 <- brks[,(chr.brk[one.chr]+1):chr.brk[one.chr+1]]
      sel.fam.all1 <- sel.fam.all[,chr.brk[one.chr]:(chr.brk[one.chr+1]-1)]
      if (one.chr>1) {brks1 <- brks1- brks[1,chr.brk[one.chr]];brks1<-cbind(rep(0,n.ped),brks1)}
      for (k in 1:(ncol(brks1)-1)){
        if (mf.flip[i,k]==1) {
          mom1 <- as.numeric(c(mom1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
          dad1 <- as.numeric(c(dad1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        } else {
        mom1 <- as.numeric(c(mom1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        dad1 <- as.numeric(c(dad1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        }
        kid1 <- as.numeric(c(kid1,kid[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      }
      moms <- rbind(moms,mom1)
      dads <- rbind(dads,dad1)
      kids <- rbind(kids,kid1)
    }
    rm(mom,dad,kid) ; gc()
    geno.all <- moms; rm(moms);gc()
    geno.all <- rbind(geno.all,dads); rm(dads);gc()
    geno.all <- rbind(geno.all,kids); rm(kids);gc()
    
    ### due to fill in zero's at the creating target snp genotypes to maxize sample size, spliced data wil be different. Fill in with pathway.all results ##
    geno.all[,chr.pos[risk.chr==one.chr]] <- pathway.all[,risk.chr==one.chr]
    ## genotyping coded as 1, 2, 3 1 being rarest
    geno.all <- 3-geno.all
    
    fam.all <- data.frame(rep(1:n.ped,3),paste(rep(1:n.ped,3),rep(c(3,2,1),each=n.ped),sep="_"),rep(c(0,0,3),each=n.ped),rep(c(0,0,2),each=n.ped),rep(c(2,1,0),each=n.ped),rep(c(1,1,2),each=n.ped))
    colnames(fam.all) <- c('PID','UPN','MID','FID','Gender','Aff')
    rownames(geno.all) <- fam.all$UPN
    colnames(geno.all) <- colnames(geno.mom$genotype@.Data)
    geno.all <- new('SnpMatrix',geno.all) 
    snpStats::write.plink(paste(out.put.file,chr,'sim',sep=''), snp.major = TRUE, geno.all,
                pedigree=fam.all$PID, id=fam.all$UPN, father=fam.all$FID, mother=fam.all$MID, sex=fam.all$Gender, phenotype=fam.all$Aff,
                chromosome=geno.mom$map$chromosome, genetic.distance=geno.mom$map$cM, position=geno.mom$map$position, allele.1=geno.mom$map$allele.1, allele.2=geno.mom$map$allele.2,
                na.code = 0)
    rm(geno.all,geno.mom);gc()
  }
  if (is.na(no_cores)) no_cores <- ceiling(parallel::detectCores()/2)
  cl<-parallel::makeCluster(no_cores)
  doParallel::registerDoParallel(cl)
  foreach::foreach(one.chr = 1:length(unique(snp.all2$V1)), 
          .combine = rbind, 
          .export = c('sel.fam.all')) %dopar%  
      splice.chr(one.chr)
  # Finish
  #getDoParWorkers()  
  parallel::stopCluster(cl)
  foreach::registerDoSEQ()
}

#' TrioSim: simulate realistic trio genotypes
#'
#' @param input.plink.file for simulations of homogenous population, it is a vector of three character strings for the base filenames of the mother's
#' father's and child's plink base filenames. The plink files are in bed format and three files with 
#' extensions .bed .bim and .fam are expected for each individual's genotypes. The mothers, fathers, and 
#' childredn must be from the same set of trio families even though the ordering of the families can be different
#' for the three sets of data. For simulations under population stratification it is a list of two vectors. Each vector is a vector 
#' of three character strings for the base filenames as described above.The two vectors correspond to the two subpopulations.
#' @param out.put.file is a character string giving the base file name for the output file. The final file name also contains information on chromosome
#' number. E.g., for a base filename "trio" and for chromosome 1 the final file name is "trio1sim".
#' @param fr.desire is a double number giving the desired frequency of the target SNPs. 
#' @param pathways is a list of vectors of integers. Each vector of integers denotes the SNPs involved in a particular pathway. E.g. list(1:4,5:8)
#' @param n.ped is an integer giving the number of trios to be simulated
#' @param N.brk is an integer giving the number of breaks to be picked for each chromosome.
#' @param target.snp is a vector of integers showing the row number of the target SNPs in the .bim file.
#' @param betas.e0 is a vector of doubles giving the beta coefficient of the logit risk model for the unexposed individuals.
#' @param betas.e is a vector of doubles giving the beta coefficient of the logit risk model for the exposed individuals.
#' @param e.fr is a double number between 0 and 1 which gives the exposure prevalence.
#' @param pop1.frac is a double number between 0 and 1 which gives the fraction of population 1 for a population stratification scenario.
#' @param rate.beta is a double number giving the log OR of disease prevalence in population 2 over that in population 1.
#' @param rcmb.rate the default value is NA. rcmb.rate is a dataframe containing the recombination rates at each SNP. The ordering of the SNPs should 
#' be identical to that of snp.all2. It contains 4 columns with column names "V1", "V2","V3",and "V4" with the 
#' corresponding values for "the chromosomal number", "SNP rs number", "chromosomal position",
#' and "recombination rate". The recombination rate represents the maximum recombination rate in the chromosomal
#' region between the current SNP and the SNP above (or the first basepair of the chromosome for the first SNP on a chromosome).
#' When no rcmb.rate is provided the function will pick the breaking points randomly where keeping the breaking
#' points in between target SNPs.
#' @param no_cores is an integer which specifies the number of CPU cores to parallelized.
#' @param qtl is a boolean variable denoting whether a quantitative trait (qtl=TRUE) or a binary trait (qtl=FALSE) is to be simulated. For a binary trait only affected 
#' families will be kept. The default value is qtl=FALSE.
#'
#' @return this function  simulates trios and writes PLINK files into the current directory. Each set of PLINK files contains genotype
#' data for one chromosome for all trios. The first third of the rows are genotypes of the mothers'. The seond third are those of the fathers' and the last third are the 
#' children's. 
#' @export
#'
#' @examples 
#' baseFilename <- system.file("extdata", "pop1_4chr_dad.bed", package = "TrioSim")
#' baseFilename <- sub('pop1_4chr_dad.bed','',baseFilename)
#' input.plink.file <- c(paste(baseFilename,'pop1_4chr_mom.bed',sep=''),paste(baseFilename,'pop1_4chr_dad.bed',sep=''),
#' paste(baseFilename,'pop1_4chr_kid.bed',sep=''))

#' TrioSim(input.plink.file, 'pop1_', fr.desire=0.05,pathways=list(1:4,5:8),n.ped=1000, N.brk=3, target.snp=NA,
#' betas.e0=c(0,0,0), betas.e1=c(0,0,0), e.fr=NA, pop1.frac=NA, rate.beta=0,rcmb.rate, no_cores=NA)
TrioSim <- function(input.plink.file, out.put.file, fr.desire,pathways,n.ped, N.brk, target.snp=NA,
                    betas.e0, betas.e1, e.fr, pop1.frac, rate.beta,rcmb.rate=NA, no_cores=NA,qtl=FALSE) {
  
  if (length(input.plink.file)==2) two.pop <- T else two.pop <- F
  if (two.pop) file1 <- input.plink.file[[1]] else file1 <- input.plink.file
  ### pick target SNPs if not already given. For stratified scenario only allele frequency in the first subpopulation determine SNP selection
  if (is.na(target.snp)) {
    n.snp <- length(unique(unlist(pathways)))
    pick.snp <- pick_target.snp(input.plink.file, fr.desire,n.snp) 
    snp.all2 <- pick.snp[[1]]
    target.snp <- pick.snp[[2]]
  } else if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  ### get target SNP genotypes 
  if (!two.pop) {
    tar.geno <- get.target.geno(input.plink.file, target.snp,snp.all2)
    mom.tar <- tar.geno[[1]]
    dad.tar <- tar.geno[[2]]
    kid.tar <- tar.geno[[3]]
  } else {
    tar.geno <- get.target.geno(input.plink.file[[1]], target.snp,snp.all2)
    mom1.tar <- tar.geno[[1]]
    dad1.tar <- tar.geno[[2]]
    kid1.tar <- tar.geno[[3]]
    tar.geno <- get.target.geno(input.plink.file[[2]], target.snp,snp.all2)
    mom2.tar <- tar.geno[[1]]
    dad2.tar <- tar.geno[[2]]
    kid2.tar <- tar.geno[[3]]
    
    mom.tar <- list(mom1.tar, mom2.tar)
    dad.tar <- list(dad1.tar, dad2.tar)
    kid.tar <- list(kid1.tar, kid2.tar)
  }
  ### get breaking points
  brks <- get.brks(N.brk,n.ped, snp.all2,target.snp,rcmb.rate)
  fam.pos <- brks[[2]]
  brks <- brks[[1]]
  ### fit risk
  fit.risk <- fit.risk.model.par(n.ped,brks,target.snp,fam.pos, mom.tar,dad.tar, kid.tar, pathways, betas.e0,e.fr, betas.e1,pop1.frac, rate.beta,qtl,out.put.file,no_cores)
  sel.fam.all <- fit.risk[[1]]
  pathway.all <- fit.risk[[2]]
  e.vec <- fit.risk[[3]]
  pop.vec <- fit.risk[[4]]
  ### splice chromosomal fragments together
  glue.chr.segment.par(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec,no_cores)
}

TrioSim2 <- function(input.plink.file, out.put.file, fr.desire,pathways,n.ped, N.brk, target.snp=NA,
                    betas.e0, betas.e1, e.fr, pop1.frac, rate.beta,rcmb.rate=NA, no_cores=NA,qtl=FALSE,same.brk=FALSE) {
  
  if (length(input.plink.file)==2) two.pop <- T else two.pop <- F
  if (two.pop) file1 <- input.plink.file[[1]] else file1 <- input.plink.file
  ### pick target SNPs if not already given. For stratified scenario only allele frequency in the first subpopulation determine SNP selection
  if (is.na(target.snp)) {
    n.snp <- length(unique(unlist(pathways)))
    pick.snp <- pick_target.snp(input.plink.file, fr.desire,n.snp) 
    snp.all2 <- pick.snp[[1]]
    target.snp <- pick.snp[[2]]
  } else if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  ### get target SNP genotypes 
  if (!two.pop) {
    tar.geno <- get.target.geno(input.plink.file, target.snp,snp.all2)
    mom.tar <- tar.geno[[1]]
    dad.tar <- tar.geno[[2]]
    kid.tar <- tar.geno[[3]]
  } else {
    tar.geno <- get.target.geno(input.plink.file[[1]], target.snp,snp.all2)
    mom1.tar <- tar.geno[[1]]
    dad1.tar <- tar.geno[[2]]
    kid1.tar <- tar.geno[[3]]
    tar.geno <- get.target.geno(input.plink.file[[2]], target.snp,snp.all2)
    mom2.tar <- tar.geno[[1]]
    dad2.tar <- tar.geno[[2]]
    kid2.tar <- tar.geno[[3]]
    
    mom.tar <- list(mom1.tar, mom2.tar)
    dad.tar <- list(dad1.tar, dad2.tar)
    kid.tar <- list(kid1.tar, kid2.tar)
  }
  ### get breaking points
  brks <- get.brks(N.brk,n.ped, snp.all2,target.snp,rcmb.rate,same.brk)
  fam.pos <- brks[[2]]
  brks <- brks[[1]]
  ### fit risk
  fit.risk <- fit.risk.model.par(n.ped,brks,target.snp,fam.pos, mom.tar,dad.tar, kid.tar, pathways, betas.e0,e.fr, betas.e1,pop1.frac, rate.beta,qtl,out.put.file,no_cores)
  sel.fam.all <- fit.risk[[1]]
  pathway.all <- fit.risk[[2]]
  e.vec <- fit.risk[[3]]
  pop.vec <- fit.risk[[4]]
  ### splice chromosomal fragments together
  glue.chr.segment.par2(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec,no_cores)
}

glue.chr.segment.par2 <- function(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec=NA,no_cores=NA) {
  if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  n.ped <- nrow(brks)
  sel.fam.all.org <- sel.fam.all
  chr.brk <- c(0,which(brks[1,]%in%cumsum(table(snp.all2$V1))))
  risk.chr <-  sapply(target.snp,function(v){sum(v>cumsum(table(snp.all2$V1)))+1})
  chr.pos <- target.snp - c(0,cumsum(table(snp.all2$V1)))[risk.chr]
  
  input.plink.file.org <- input.plink.file
  if (length(input.plink.file)==2) pop <- 2 else pop <- 1
  
  ### randomly switch mother/father to remove maternal effects in the original data #########
  mf.flip <- matrix(rbinom(n.ped*(ncol(brks)-1),1,0.5),ncol=ncol(brks)-1,nrow=n.ped)
  splice.chr <- function(i) {
    
    mom1 <- NULL
    dad1 <- NULL
    kid1 <- NULL
    
    brks1 <- brks[,(chr.brk[one.chr]+1):chr.brk[one.chr+1]]
    sel.fam.all1 <- sel.fam.all[,chr.brk[one.chr]:(chr.brk[one.chr+1]-1)]
    if (one.chr>1) {brks1 <- brks1- brks[1,chr.brk[one.chr]];brks1<-cbind(rep(0,n.ped),brks1)}
    for (k in 1:(ncol(brks1)-1)){
      if (mf.flip[i,k]==1) {
        mom1 <- as.numeric(c(mom1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        dad1 <- as.numeric(c(dad1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      } else {
        mom1 <- as.numeric(c(mom1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        dad1 <- as.numeric(c(dad1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      }
      kid1 <- as.numeric(c(kid1,kid[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
    }
    c(mom1,dad1,kid1)
  }
  
  for (one.chr in 1:length(unique(snp.all2$V1)) ) {
    mom.all <- NULL
    dad.all <- NULL
    kid.all <- NULL
    n.ped.pop1 <-0
    for (p in 1:pop) {
      chr <- unique(snp.all2$V1)[one.chr]
      if (pop==1) {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      } else {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[[p]][1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[[p]][2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[[p]][3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      }
      mom <- geno.mom$genotype@.Data
      mom <- mom[order(rownames(mom)),]
      dad <- geno.dad$genotype@.Data
      dad <- dad[order(rownames(dad)),]
      kid <- geno.kid$genotype@.Data
      kid <- kid[order(rownames(kid)),]
      geno.mom$genotype <-NULL
      
      rm(geno.dad,geno.kid)
      gc()
      mom <- matrix(as.numeric(mom),byrow=F,ncol=ncol(mom))
      dad <- matrix(as.numeric(dad),byrow=F,ncol=ncol(mom))
      kid <- matrix(as.numeric(kid),byrow=F,ncol=ncol(mom))
      mom[mom==0] <- NA; mom <- mom-1
      dad[dad==0] <- NA; dad <- dad-1
      kid[kid==0] <- NA; kid <- kid-1
      
      na.sel <- sum(is.na(mom)|is.na(dad)|is.na(kid))
      mom[na.sel] <-0
      dad[na.sel] <-0
      kid[na.sel] <-0
      comp <- mom+dad-kid
      
      mom[!(comp%in%c(0,1,2))] <- 0
      dad[!(comp%in%c(0,1,2))] <- 0
      kid[!(comp%in%c(0,1,2))] <- 0
      comp[!(comp%in%c(0,1,2))] <- 0
      mom <- 2-mom
      dad <- 2-dad
      kid <- 2-kid
      comp <- 2-comp
      ### stack case trio on top of comp trio
      mom.all <- rbind(mom.all,mom,mom)
      rm(mom);gc()
      dad.all <- rbind(dad.all,dad,dad)
      rm(dad);gc()
      kid.all <- rbind(kid.all, kid, comp)
      rm(kid,comp);gc()
      
      if (p==1 & pop==2) n.ped.pop1 <- nrow(mom.all)
    }
    mom <- mom.all; rm(mom.all);gc()
    dad <- dad.all; rm(dad.all);gc()
    kid <- kid.all; rm(kid.all);gc()
    #  brks <- brks.org
    if (pop==2) sel.fam.all[pop.vec==2,] <- sel.fam.all.org[pop.vec==2,] + n.ped.pop1
    
    moms<- NULL
    dads <- NULL
    kids <- NULL
    
    if (is.na(no_cores)) no_cores <- parallel::detectCores() - 1
    cl<-parallel::makeCluster(no_cores)
    doParallel::registerDoParallel(cl)
    
    geno.mfc <-  foreach::foreach(i = 1:n.ped, 
                                  .combine = rbind) %dopar%  
      splice.chr(i)
    # Finish
    #getDoParWorkers()  
    parallel::stopCluster(cl)
    foreach::registerDoSEQ()
    
    rm(mom,dad,kid) ; gc()
    n.snp <- ncol(geno.mfc)/3
    geno.all <- geno.mfc[,1:n.snp]; 
    geno.all <- rbind(geno.all,geno.mfc[,1:n.snp+n.snp]);
    geno.all <- rbind(geno.all,geno.mfc[,1:n.snp+n.snp]); 
    
    ### due to fill in zero's at the creating target snp genotypes to maxize sample size, spliced data wil be different. Fill in with pathway.all results ##
    geno.all[,chr.pos[risk.chr==one.chr]] <- pathway.all[,risk.chr==one.chr]
    ## genotyping coded as 1, 2, 3 1 being rarest
    geno.all <- 3-geno.all
    
    fam.all <- data.frame(rep(1:n.ped,3),paste(rep(1:n.ped,3),rep(c(3,2,1),each=n.ped),sep="_"),rep(c(0,0,3),each=n.ped),rep(c(0,0,2),each=n.ped),rep(c(2,1,0),each=n.ped),rep(c(1,1,2),each=n.ped))
    colnames(fam.all) <- c('PID','UPN','MID','FID','Gender','Aff')
    rownames(geno.all) <- fam.all$UPN
    colnames(geno.all) <- colnames(geno.mom$genotype@.Data)
    geno.all <- new('SnpMatrix',geno.all) 
    snpStats::write.plink(paste(out.put.file,chr,'sim',sep=''), snp.major = TRUE, geno.all,
                          pedigree=fam.all$PID, id=fam.all$UPN, father=fam.all$FID, mother=fam.all$MID, sex=fam.all$Gender, phenotype=fam.all$Aff,
                          chromosome=geno.mom$map$chromosome, genetic.distance=geno.mom$map$cM, position=geno.mom$map$position, allele.1=geno.mom$map$allele.1, allele.2=geno.mom$map$allele.2,
                          na.code = 0)
    rm(geno.all,geno.mom);gc()
  }
}

glue.chr.segment.par3 <- function(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec=NA,no_cores=NA,para=T) {
  if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  n.ped <- nrow(brks)
  sel.fam.all.org <- sel.fam.all
  chr.brk <- c(0,which(brks[1,]%in%cumsum(table(snp.all2$V1))))
  risk.chr <-  sapply(target.snp,function(v){sum(v>cumsum(table(snp.all2$V1)))+1})
  chr.pos <- target.snp - c(0,cumsum(table(snp.all2$V1)))[risk.chr]
  
  input.plink.file.org <- input.plink.file
  if (length(input.plink.file)==2) pop <- 2 else pop <- 1
  
  ### randomly switch mother/father to remove maternal effects in the original data #########
  mf.flip <- matrix(rbinom(n.ped*(ncol(brks)-1),1,0.5),ncol=ncol(brks)-1,nrow=n.ped)
  splice.chr <- function(i) {
    
    mom1 <- NULL
    dad1 <- NULL
    kid1 <- NULL
    
    brks1 <- brks[,(chr.brk[one.chr]+1):chr.brk[one.chr+1]]
    sel.fam.all1 <- sel.fam.all[,chr.brk[one.chr]:(chr.brk[one.chr+1]-1)]
    if (one.chr>1) {brks1 <- brks1- brks[1,chr.brk[one.chr]];brks1<-cbind(rep(0,n.ped),brks1)}
    for (k in 1:(ncol(brks1)-1)){
      if (mf.flip[i,k]==1) {
        mom1 <- as.numeric(c(mom1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        dad1 <- as.numeric(c(dad1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      } else {
        mom1 <- as.numeric(c(mom1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        dad1 <- as.numeric(c(dad1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      }
      kid1 <- as.numeric(c(kid1,kid[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
    }
    c(mom1,dad1,kid1)
  }
  
  geno.all.gwas <- NULL
  for (one.chr in 1:length(unique(snp.all2$V1)) ) {
    mom.all <- NULL
    dad.all <- NULL
    kid.all <- NULL
    n.ped.pop1 <-0
    for (p in 1:pop) {
      chr <- unique(snp.all2$V1)[one.chr]
      if (pop==1) {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      } else {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[[p]][1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[[p]][2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[[p]][3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      }
      mom <- geno.mom$genotype@.Data
      mom <- mom[order(rownames(mom)),]
      dad <- geno.dad$genotype@.Data
      dad <- dad[order(rownames(dad)),]
      kid <- geno.kid$genotype@.Data
      kid <- kid[order(rownames(kid)),]
      geno.mom$genotype <-NULL
      
      rm(geno.dad,geno.kid)
      gc()
      mom <- matrix(as.numeric(mom),byrow=F,ncol=ncol(mom))
      dad <- matrix(as.numeric(dad),byrow=F,ncol=ncol(mom))
      kid <- matrix(as.numeric(kid),byrow=F,ncol=ncol(mom))
      mom[mom==0] <- NA; mom <- mom-1
      dad[dad==0] <- NA; dad <- dad-1
      kid[kid==0] <- NA; kid <- kid-1
      
      na.sel <- sum(is.na(mom)|is.na(dad)|is.na(kid))
      mom[na.sel] <-0
      dad[na.sel] <-0
      kid[na.sel] <-0
      comp <- mom+dad-kid
      
      mom[!(comp%in%c(0,1,2))] <- 0
      dad[!(comp%in%c(0,1,2))] <- 0
      kid[!(comp%in%c(0,1,2))] <- 0
      comp[!(comp%in%c(0,1,2))] <- 0
      mom <- 2-mom
      dad <- 2-dad
      kid <- 2-kid
      comp <- 2-comp
      ### stack case trio on top of comp trio
      mom.all <- rbind(mom.all,mom,mom)
      rm(mom);gc()
      dad.all <- rbind(dad.all,dad,dad)
      rm(dad);gc()
      kid.all <- rbind(kid.all, kid, comp)
      rm(kid,comp);gc()
      
      if (p==1 & pop==2) n.ped.pop1 <- nrow(mom.all)
    }
    mom <- mom.all; rm(mom.all);gc()
    dad <- dad.all; rm(dad.all);gc()
    kid <- kid.all; rm(kid.all);gc()
    #  brks <- brks.org
    if (pop==2) sel.fam.all[pop.vec==2,] <- sel.fam.all.org[pop.vec==2,] + n.ped.pop1
    
    moms<- NULL
    dads <- NULL
    kids <- NULL
   
     
   if (para) {   
   if (is.na(no_cores)) no_cores <- parallel::detectCores() - 1
    cl<-parallel::makeCluster(no_cores)
    doParallel::registerDoParallel(cl)
    
    geno.mfc <-  foreach::foreach(i = 1:n.ped, 
                                  .combine = rbind) %dopar%  
      splice.chr(i)
    # Finish
    #getDoParWorkers()  
    parallel::stopCluster(cl)
    foreach::registerDoSEQ()
   } else {
     geno.mfc <-  foreach::foreach(i = 1:n.ped, 
                                   .combine = rbind) %do%  
       splice.chr(i)
   #  parallel::stopCluster(cl)
   #  foreach::registerDoSEQ()
    }
    rm(mom,dad,kid) ; gc()
    n.snp <- ncol(geno.mfc)/3
    geno.all <- geno.mfc[,1:n.snp]; 
    geno.all <- rbind(geno.all,geno.mfc[,1:n.snp+n.snp]);
    geno.all <- rbind(geno.all,geno.mfc[,1:n.snp+n.snp]); 
    geno.all.gwas <- cbind(geno.all.gwas, geno.all)
    rm(geno.all,geno.mfc);gc()
  }
  ### due to fill in zero's at the creating target snp genotypes to maxize sample size, spliced data wil be different. Fill in with pathway.all results ##
  geno.all.gwas[,target.snp] <- pathway.all
  geno.all.gwas
}

glue.chr.segment.par4 <- function(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec=NA,no_cores=NA) {
  if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  n.ped <- nrow(brks)
  sel.fam.all.org <- sel.fam.all
  chr.brk <- c(0,which(brks[1,]%in%cumsum(table(snp.all2$V1))))
  risk.chr <-  sapply(target.snp,function(v){sum(v>cumsum(table(snp.all2$V1)))+1})
  chr.pos <- target.snp - c(0,cumsum(table(snp.all2$V1)))[risk.chr]
  
  input.plink.file.org <- input.plink.file
  if (length(input.plink.file)==2) pop <- 2 else pop <- 1
  
  ### randomly switch mother/father to remove maternal effects in the original data #########
  mf.flip <- matrix(rbinom(n.ped*(ncol(brks)-1),1,0.5),ncol=ncol(brks)-1,nrow=n.ped)
  splice.chr <- function(one.chr) {
    mom.all <- NULL
    dad.all <- NULL
    kid.all <- NULL
    n.ped.pop1 <-0
    for (p in 1:pop) {
      chr <- unique(snp.all2$V1)[one.chr]
      if (pop==1) {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      } else {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[[p]][1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[[p]][2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[[p]][3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      }
      mom <- geno.mom$genotype@.Data
      mom <- mom[order(rownames(mom)),]
      dad <- geno.dad$genotype@.Data
      dad <- dad[order(rownames(dad)),]
      kid <- geno.kid$genotype@.Data
      kid <- kid[order(rownames(kid)),]
      geno.mom$genotype <-NULL
      
      rm(geno.dad,geno.kid)
      gc()
      mom <- matrix(as.numeric(mom),byrow=F,ncol=ncol(mom))
      dad <- matrix(as.numeric(dad),byrow=F,ncol=ncol(mom))
      kid <- matrix(as.numeric(kid),byrow=F,ncol=ncol(mom))
      mom[mom==0] <- NA; mom <- mom-1
      dad[dad==0] <- NA; dad <- dad-1
      kid[kid==0] <- NA; kid <- kid-1
      
      na.sel <- sum(is.na(mom)|is.na(dad)|is.na(kid))
      mom[na.sel] <-0
      dad[na.sel] <-0
      kid[na.sel] <-0
      comp <- mom+dad-kid
      
      mom[!(comp%in%c(0,1,2))] <- 0
      dad[!(comp%in%c(0,1,2))] <- 0
      kid[!(comp%in%c(0,1,2))] <- 0
      comp[!(comp%in%c(0,1,2))] <- 0
      mom <- 2-mom
      dad <- 2-dad
      kid <- 2-kid
      comp <- 2-comp
      ### stack case trio on top of comp trio
      mom.all <- rbind(mom.all,mom,mom)
      rm(mom);gc()
      dad.all <- rbind(dad.all,dad,dad)
      rm(dad);gc()
      kid.all <- rbind(kid.all, kid, comp)
      rm(kid,comp);gc()
      
      if (p==1 & pop==2) n.ped.pop1 <- nrow(mom.all)
    }
    mom <- mom.all; rm(mom.all);gc()
    dad <- dad.all; rm(dad.all);gc()
    kid <- kid.all; rm(kid.all);gc()
    #  brks <- brks.org
    if (pop==2) sel.fam.all[pop.vec==2,] <- sel.fam.all.org[pop.vec==2,] + n.ped.pop1
    
    moms<- NULL
    dads <- NULL
    kids <- NULL
    for (i in 1:n.ped) {
      mom1 <- NULL
      dad1 <- NULL
      kid1 <- NULL
      
      brks1 <- brks[,(chr.brk[one.chr]+1):chr.brk[one.chr+1]]
      sel.fam.all1 <- sel.fam.all[,chr.brk[one.chr]:(chr.brk[one.chr+1]-1)]
      if (one.chr>1) {brks1 <- brks1- brks[1,chr.brk[one.chr]];brks1<-cbind(rep(0,n.ped),brks1)}
      for (k in 1:(ncol(brks1)-1)){
        if (mf.flip[i,k]==1) {
          mom1 <- as.numeric(c(mom1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
          dad1 <- as.numeric(c(dad1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        } else {
          mom1 <- as.numeric(c(mom1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
          dad1 <- as.numeric(c(dad1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        }
        kid1 <- as.numeric(c(kid1,kid[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      }
      moms <- rbind(moms,mom1)
      dads <- rbind(dads,dad1)
      kids <- rbind(kids,kid1)
    }
    rm(mom,dad,kid) ; gc()
    geno.all <- moms; rm(moms);gc()
    geno.all <- rbind(geno.all,dads); rm(dads);gc()
    geno.all <- rbind(geno.all,kids); rm(kids);gc()
    
    ### due to fill in zero's at the creating target snp genotypes to maxize sample size, spliced data wil be different. Fill in with pathway.all results ##
    geno.all[,chr.pos[risk.chr==one.chr]] <- pathway.all[,risk.chr==one.chr]
    geno.all
  }
  if (is.na(no_cores)) no_cores <- parallel::detectCores() - 1
  cl<-parallel::makeCluster(no_cores)
  doParallel::registerDoParallel(cl)
  geno.gwas <- foreach::foreach(one.chr = 1:length(unique(snp.all2$V1)), 
                                .combine = cbind, 
                                .export = c('sel.fam.all')) %dopar%  
    splice.chr(one.chr)
  # Finish
  #getDoParWorkers()  
  parallel::stopCluster(cl)
  foreach::registerDoSEQ()
  geno.gwas
}

glue.chr.segment3 <- function(input.plink.file,out.put.file, brks,sel.fam.all,snp.all2,pathway.all,target.snp,pop.vec=NA,no_cores=NA,para=T) {
  if (sum(order(target.snp)!=1:length(target.snp))>0)  stop("Target SNPs are no in the correct order of smallest to largest")
  n.ped <- nrow(brks)
  sel.fam.all.org <- sel.fam.all
  chr.brk <- c(0,which(brks[1,]%in%cumsum(table(snp.all2$V1))))
  risk.chr <-  sapply(target.snp,function(v){sum(v>cumsum(table(snp.all2$V1)))+1})
  chr.pos <- target.snp - c(0,cumsum(table(snp.all2$V1)))[risk.chr]
  
  input.plink.file.org <- input.plink.file
  if (length(input.plink.file)==2) pop <- 2 else pop <- 1
  
  ### randomly switch mother/father to remove maternal effects in the original data #########
  mf.flip <- matrix(rbinom(n.ped*(ncol(brks)-1),1,0.5),ncol=ncol(brks)-1,nrow=n.ped)
  splice.chr <- function() {
    
    mom1 <- NULL
    dad1 <- NULL
    kid1 <- NULL
    
    brks1 <- brks[,(chr.brk[one.chr]+1):chr.brk[one.chr+1]]
    sel.fam.all1 <- sel.fam.all[,chr.brk[one.chr]:(chr.brk[one.chr+1]-1)]
    if (one.chr>1) {brks1 <- brks1- brks[1,chr.brk[one.chr]];brks1<-cbind(rep(0,n.ped),brks1)}
    for (k in 1:(ncol(brks1)-1)){
      if (mf.flip[i,k]==1) {
        mom1 <- as.numeric(c(mom1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        dad1 <- as.numeric(c(dad1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      } else {
        mom1 <- as.numeric(c(mom1,mom[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
        dad1 <- as.numeric(c(dad1,dad[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
      }
      kid1 <- as.numeric(c(kid1,kid[sel.fam.all1[i,k],(brks1[i,k]+1):brks1[i,k+1]]))
    }
    c(mom1,dad1,kid1)
  }
  
  geno.all.gwas <- NULL
  for (one.chr in 1:length(unique(snp.all2$V1)) ) {
    mom.all <- NULL
    dad.all <- NULL
    kid.all <- NULL
    n.ped.pop1 <-0
    for (p in 1:pop) {
      chr <- unique(snp.all2$V1)[one.chr]
      if (pop==1) {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      } else {
        geno.mom <- snpStats::read.plink(paste(input.plink.file[[p]][1],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.dad <- snpStats::read.plink(paste(input.plink.file[[p]][2],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
        geno.kid <- snpStats::read.plink(paste(input.plink.file[[p]][3],'bed',sep='.'),select.snps= snp.all2[snp.all2$V1==chr,'V2'], na.strings = ("-9"))
      }
      mom <- geno.mom$genotype@.Data
      mom <- mom[order(rownames(mom)),]
      dad <- geno.dad$genotype@.Data
      dad <- dad[order(rownames(dad)),]
      kid <- geno.kid$genotype@.Data
      kid <- kid[order(rownames(kid)),]
      geno.mom$genotype <-NULL
      
      rm(geno.dad,geno.kid)
      gc()
      mom <- matrix(as.numeric(mom),byrow=F,ncol=ncol(mom))
      dad <- matrix(as.numeric(dad),byrow=F,ncol=ncol(mom))
      kid <- matrix(as.numeric(kid),byrow=F,ncol=ncol(mom))
      mom[mom==0] <- NA; mom <- mom-1
      dad[dad==0] <- NA; dad <- dad-1
      kid[kid==0] <- NA; kid <- kid-1
      
      na.sel <- sum(is.na(mom)|is.na(dad)|is.na(kid))
      mom[na.sel] <-0
      dad[na.sel] <-0
      kid[na.sel] <-0
      comp <- mom+dad-kid
      
      mom[!(comp%in%c(0,1,2))] <- 0
      dad[!(comp%in%c(0,1,2))] <- 0
      kid[!(comp%in%c(0,1,2))] <- 0
      comp[!(comp%in%c(0,1,2))] <- 0
      mom <- 2-mom
      dad <- 2-dad
      kid <- 2-kid
      comp <- 2-comp
      ### stack case trio on top of comp trio
      mom.all <- rbind(mom.all,mom,mom)
      rm(mom);gc()
      dad.all <- rbind(dad.all,dad,dad)
      rm(dad);gc()
      kid.all <- rbind(kid.all, kid, comp)
      rm(kid,comp);gc()
      
      if (p==1 & pop==2) n.ped.pop1 <- nrow(mom.all)
    }
    mom <- mom.all; rm(mom.all);gc()
    dad <- dad.all; rm(dad.all);gc()
    kid <- kid.all; rm(kid.all);gc()
    #  brks <- brks.org
    if (pop==2) sel.fam.all[pop.vec==2,] <- sel.fam.all.org[pop.vec==2,] + n.ped.pop1
    
    moms<- NULL
    dads <- NULL
    kids <- NULL
    
    geno.mfc <- NULL
    for (i in 1:n.ped) geno.mfc <- rbind(geno.mfc,splice.chr() )
 
    rm(mom,dad,kid) ; gc()
    n.snp <- ncol(geno.mfc)/3
    geno.all <- geno.mfc[,1:n.snp]; 
    geno.all <- rbind(geno.all,geno.mfc[,1:n.snp+n.snp]);
    geno.all <- rbind(geno.all,geno.mfc[,1:n.snp+n.snp]); 
    geno.all.gwas <- cbind(geno.all.gwas, geno.all)
    rm(geno.all,geno.mfc);gc()
  }
  ### due to fill in zero's at the creating target snp genotypes to maxize sample size, spliced data wil be different. Fill in with pathway.all results ##
  geno.all.gwas[,target.snp] <- pathway.all
  geno.all.gwas
}


